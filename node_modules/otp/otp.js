'use strict';

const VOCAB = "ABCDEFGHIJKLMNOPQRSTUVWXYZ23456789=".split("");
function encodeChunk(data) {
    const b1 = data.length > 0 ? data[0] : 0;
    const b2 = data.length > 1 ? data[1] : 0;
    const b3 = data.length > 2 ? data[2] : 0;
    const b4 = data.length > 3 ? data[3] : 0;
    const b5 = data.length > 4 ? data[4] : 0;
    const chars = [map(mask(b1 >> 3)), map(mask((b1 << 2) | (b2 >> 5))), map(mask(b2 >> 1)), map(mask((b2 << 4) | (b3 >> 4))), map(mask((b3 << 1) | (b4 >> 7))), map(mask(b4 >> 2)), map(mask((b4 << 3) | (b5 >> 5))), map(mask(b5))];
    switch (data.length) {
        case 0:
            return "";
        case 1:
        case 2:
        case 3:
        case 4:
        default:
            return chars.join("");
    }
}
function mask(n) {
    return n & 0b00011111;
}
function map(n) {
    return n > -1 && n < VOCAB.length ? VOCAB[n] : "=";
}
function encode(data) {
    let offset = 0;
    const chunks = [];
    while (offset < data.length) {
        const subset = data.subarray(offset, offset + 5);
        chunks.push(encodeChunk(subset));
        offset += subset.length;
    }
    return chunks.join("");
}
function decodeChar(data) {
    const index = VOCAB.indexOf(data);
    if (index < 0)
        throw new Error("invalid character: " + data);
    if (index === VOCAB.length - 1)
        return 0;
    return Math.max(index, 0);
}
function decodeChunk(data, dest) {
    const c1 = decodeChar(data[0]);
    const c2 = decodeChar(data[1]);
    const c3 = decodeChar(data[2]);
    const c4 = decodeChar(data[3]);
    const c5 = decodeChar(data[4]);
    const c6 = decodeChar(data[5]);
    const c7 = decodeChar(data[6]);
    const c8 = decodeChar(data[7]);
    dest[0] = byte((c1 << 3) | (c2 >> 2));
    dest[2] = byte((c2 << 5) | (c3 << 1) | (c4 >> 4));
    dest[3] = byte((c4 << 4) | (c5 >> 1));
    dest[5] = byte((c5 << 7) | (c6 << 2) | (c7 >> 3));
    dest[6] = byte((c7 << 5) | c8);
}
function byte(n) {
    return n & 0xff;
}
function decode(data) {
    data = data
        .split("s+")
        .map((s) => s.trim())
        .join("");
    const dest = new Uint8Array((data.length * 5) / 8);
    const chars = data.split("");
    let coff = 0;
    let boff = 0;
    let fin = 5;
    while (fin == 5 && coff < chars.length && boff < dest.length) {
        const chunk = chars.slice(coff, coff + 8);
        if (chunk.indexOf("=") > -1) {
            chunk.splice(chunk.indexOf("="), 8);
            switch (chunk.length) {
                case 2:
                    fin = 1;
                    break;
                case 4:
                    fin = 2;
                    break;
                case 5:
                    fin = 3;
                    break;
                case 7:
                    fin = 4;
                    break;
                default:
                    throw new Error("invalid padding");
            }
        }
        decodeChunk(chunk, dest.subarray(boff, boff + 5));
        coff += 8;
        boff += 5;
    }
    return dest.subarray(0, dest.length - 5 + fin);
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var crypt = createCommonjsModule(function (module) {
(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();
});

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

var charenc_1 = charenc;

var sha1 = createCommonjsModule(function (module) {
(function() {
  var crypt$1 = crypt,
      utf8 = charenc_1.utf8,
      bin = charenc_1.bin,

  // The core
  sha1 = function (message) {
    // Convert to byte array
    if (message.constructor == String)
      message = utf8.stringToBytes(message);
    else if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();

    // otherwise assume byte array

    var m  = crypt$1.bytesToWords(message),
        l  = message.length * 8,
        w  = [],
        H0 =  1732584193,
        H1 = -271733879,
        H2 = -1732584194,
        H3 =  271733878,
        H4 = -1009589776;

    // Padding
    m[l >> 5] |= 0x80 << (24 - l % 32);
    m[((l + 64 >>> 9) << 4) + 15] = l;

    for (var i = 0; i < m.length; i += 16) {
      var a = H0,
          b = H1,
          c = H2,
          d = H3,
          e = H4;

      for (var j = 0; j < 80; j++) {

        if (j < 16)
          w[j] = m[i + j];
        else {
          var n = w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16];
          w[j] = (n << 1) | (n >>> 31);
        }

        var t = ((H0 << 5) | (H0 >>> 27)) + H4 + (w[j] >>> 0) + (
                j < 20 ? (H1 & H2 | ~H1 & H3) + 1518500249 :
                j < 40 ? (H1 ^ H2 ^ H3) + 1859775393 :
                j < 60 ? (H1 & H2 | H1 & H3 | H2 & H3) - 1894007588 :
                         (H1 ^ H2 ^ H3) - 899497514);

        H4 = H3;
        H3 = H2;
        H2 = (H1 << 30) | (H1 >>> 2);
        H1 = H0;
        H0 = t;
      }

      H0 += a;
      H1 += b;
      H2 += c;
      H3 += d;
      H4 += e;
    }

    return [H0, H1, H2, H3, H4];
  },

  // Public API
  api = function (message, options) {
    var digestbytes = crypt$1.wordsToBytes(sha1(message));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt$1.bytesToHex(digestbytes);
  };

  api._blocksize = 16;
  api._digestsize = 20;

  module.exports = api;
})();
});

class Hash {
    constructor() {
        this.data = [];
    }
    update(data) {
        this.data.push(...data.values());
        return this;
    }
    digest() {
        return sha1(this.data, { asBytes: true });
    }
    static hash(data) {
        return new Hash().update(data).digest();
    }
}

const zeroBuffer = new Uint8Array(new Array(128).fill(0));
class Hmac {
    constructor(blocksize, key) {
        if (blocksize !== 128 && blocksize !== 64) {
            throw new Error("blocksize must be either 64 for or 128 , but was:" + blocksize);
        }
        this.key = rekey(key, blocksize);
        this.opad = new Uint8Array(new Array(blocksize).fill(0));
        this.ipad = new Uint8Array(new Array(blocksize).fill(0));
        for (var i = 0; i < blocksize; i++) {
            this.ipad[i] = this.key[i] ^ 0x36;
            this.opad[i] = this.key[i] ^ 0x5c;
        }
        this.hash = new Hash();
    }
    update(data) {
        this.hash.update(data);
        return this;
    }
    digest() {
        const hash = this.hash.digest();
        return new Hash().update(this.opad).update(hash).digest();
    }
}
function rekey(key, blocksize) {
    if (key.length > blocksize) {
        return Hash.hash(key);
    }
    if (key.length < blocksize) {
        const res = new Uint8Array(blocksize);
        res.set(key);
        res.set(zeroBuffer, key.length);
        return res;
    }
    return key;
}

class OTP {
    constructor(options = {}) {
        if ("string" === typeof options)
            return OTP.parse(options);
        options = Object.assign({}, options);
        options.name = `${options.name || "OTP-Authentication"}`.split(/[^\w|_|-|@]/).join("");
        options.keySize = options.keySize === 128 ? 128 : 64;
        options.codeLength = isNaN(options.codeLength) ? 6 : options.codeLength;
        options.secret = options.secret || generateKey(options.keySize);
        options.epoch = isNaN(options.epoch) ? 0 : options.epoch;
        options.timeSlice = isNaN(options.timeSlice) ? 30 : options.timeSlice;
        this.options = options;
        this.hotp = hotp.bind(null, options);
        this.totp = totp.bind(null, options);
    }
    get name() {
        return this.options.name;
    }
    get secret() {
        return this.options.secret;
    }
    get totpURL() {
        return ["otpauth://totp/", this.name, "?secret=", encodeURIComponent(this.secret)].join("");
    }
    get hotpURL() {
        return ["otpauth://hotp/", this.name, "?secret=", encodeURIComponent(this.secret)].join("");
    }
    toString() {
        return "[object OTP]";
    }
    toJSON() {
        return Object.assign({ class: OTP.classID }, this.options);
    }
    static reviveJSON(_, val) {
        if ("object" !== typeof val || null === val || val["class"] !== OTP.classID)
            return val;
        const { name, keySize, codeLength, secret, epoch, timeSlice } = val;
        return new OTP({ name, keySize, codeLength, secret, epoch, timeSlice });
    }
    static parse(urlstr = "", options = {}) {
        options = Object.assign({}, options);
        const urlbits = /^otpauth:\/\/[t|h]otp\/([\s|\S]+?)\?secret=([\s|\S]+)$/.exec(urlstr);
        if (urlbits) {
            options.name = urlbits[1];
            options.secret = encode(decode(urlbits[2]));
        }
        else {
            options.secret = encode(decode(urlstr));
        }
        return new OTP(options);
    }
}
OTP.classID = "OTP{@pipobscure}";
function hotp(options, counter) {
    const digest = new Hmac(options.keySize, decode(options.secret)).update(UInt64Buffer(counter)).digest();
    const offset = digest[19] & 0xf;
    const code = String(((digest[offset] & 0x7f) << 24) | ((digest[offset + 1] & 0xff) << 16) | ((digest[offset + 2] & 0xff) << 8) | (digest[offset + 3] & 0xff));
    return `${new Array(options.codeLength).fill("0")}${code}`.slice(-1 * options.codeLength);
}
function totp(options, now = Date.now()) {
    console.error(now, options);
    const counter = Math.floor((now - options.epoch * 1000) / (options.timeSlice * 1000));
    return hotp(options, counter);
}
function generateKey(length) {
    const key = new Uint8Array(new Array(length).fill(0).map(() => Math.floor(Math.random() * 256)));
    return encode(key).replace(/=/g, "");
}
function UInt64Buffer(num) {
    const res = Buffer.alloc(8);
    res.writeBigUInt64BE(BigInt(num));
    return res;
}

module.exports = OTP;
